/* List 7.9 - программа реализующая рекурсию в структурах. Строит двоичное дерево. */
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <windows.h>

using namespace std;

struct tnod // базовый узел
{
	char* word; // значение переменной - сивольная строка в узле (слово)
	int count;  // здемьь накапливается число встреч данного слова

	/* левый потомок: здесь хранится указатель на левый подузел, т.е. на структуру,
	в которой хранится слово меньше данного. Если слов меньших данного нет, то здесь NULL */
	struct tnod *left;

	/* правый потомок: здесь хранится указатель на правый подузел, т.е. на структуру,
	в которой хранится слово больше данного. Если слов больших данного нет, то здесь NULL */
	struct tnod *right;
};

/* Функция выделяет по malloc() память по длине строки s, и в эту пямять помещает саму строку s,
а затем выдает указатель на начало помещенной в буфер строки. */
static char* strsave(char* s)
{
	char* p;
	/* т.к. malloc() выдает указатель типа void, то принудительно приводим его к типу char, чтобы согласовать с p*/
	p = (char*)malloc(sizeof(strlen(s) + 1));
	if (p != NULL) strcpy(p, s);

	return p;
}

/* C++ позволяет объявлять структуру без слова struct */
/* Функция выделяет память под структуру tnod и возвращает указатель на эту память */
static tnod* NodAlloc(void)
{
	tnod* p = p = (tnod*)malloc(sizeof(tnod));
	return p;
}

/* Эта функция формирует двоичное дерево.
p - указатель на структуру, по которой будет создаваться новый узел или будут проверяться старые узлы.
w - слово, поступающее для его поиска в дереве.
Если такое слово уже есть, то в счетчик структуры, где оно обнаружено, добавляется единица:
подсчитывается, сколько одинаковых слов.
Если такого слова в дереве нет, то для него образуется новый узел (новая структура) */
tnod* MakeTree(tnod* p, char* w)
{
	int cond;
	if (p == NULL) // появилось новое слово. Для этого слова еще нет узла и его надо создать
	{
		p = NodAlloc(); // выделяется память под новый узел
		p->word = strsave(w); // указанное слово записывается в память и на него выдается указатель
		p->count = 1;  // слово пока единственное
		/* т.к. это слово пока последнее в дереве, то этот узел не указывает на следующие
		(меньше - слева или больше - справа) слова дерева*/
		p->left = p->right = NULL;
	}
	else if ((cond = strcmp(w, p->word)) == 0) // слово не новое, тогда оно сравнивается со словом в узле, на который указывает указатель p
		p->count++; // этом узле такое же слово, поэтому добавляем к счетчику единицу
	else if (cond < 0)
		/* слово меньше того, что в узле, поэтому его помещаем в левую часть дерева опять же с помощью этой функции.
		Ее первая часть создаст узел в динамической памяти, помест в него слово, в левые  и правые подузлы поместит NULL,
		т.к. пока дальше этого слова ни справа, ни слева ничего нет, а в левую часть узла-предка поместит указатель на эту структуру. */
		p->left = MakeTree(p->left, w);
	else if (cond > 0)
		/* слово больше того, что в узле, поэтому мы помещаем его в правую часть дерева опять же с помощью этой же функции.
		Ее первая часть создаст узел в динамической памяти, поместит в него слово, в левые и правые подузлы поместит NULL,
		т.к. пока дальше этого слова ни справа, ни слева ничего нет, а в правую часть узла-предка поместит указатель на эту структуру.*/
		p->right = MakeTree(p->right, w);
	/* возвращает указатель на область, где создана новая структура, или на структуру, в которую добавлена единица,
	т.к. поступившее слово совпадает со словом в этой структуре */
	return p;
}

/* Эта функция печатает или выводит на экран все дерево, рекурсивно себя вызывая */
static void TreePrint(tnod* p)
{
	if (p!=NULL)
	{
		TreePrint(p->left); // выводит левый узел
		cout << "p->count = " << p->count << ", p->word = " << p->word << endl;
		TreePrint(p->right); // выводит правый узел
	}
}
int main(int argcs, char* pArgs[])
{
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);

	tnod* pp;
	pp = NULL;
	char s[1000];
	
	cout << "Введите ваши слова: \n";
	cin >> s;
	while (strcmp(s, "exit")!=0)
	{
		pp = MakeTree(pp, s); // формирует очередной узел, pp всегда указывает на начало дерева
		cin >> s;
	}

	TreePrint(pp); // вывод дерева

	system("PAUSE");
	return 0;
}
